################################################################################
# .alias -- a series aliases and shell functions which act as shortcuts for
#           commands often used at Appriss.
# Version: 1.2
# Date:        Name:                   Description: 
# 2009-08-14   Barton Chittenden       Initial Version
# 2010-11-16   Barton Chittenden       Integrated commands from various machines.
################################################################################

if (echo $HOSTNAME | grep -i 'prep' > /dev/null )
then
	. $HOME/.prepfunctions
elif (echo $HOSTNAME | grep -i 'prod' > /dev/null)
then
	. $HOME/.prodfunctions
else
	. $HOME/.prodfunctions
	. $HOME/.prepfunctions
fi

################################################################################
# ruler ()
# prints an ascii ruler which runs the width of the terminal.
# Does not expect any argumens.
# Variables changed
#    None
# Requires 'ruler.pl' to be in $PATH
################################################################################
ruler ()
{
	ruler.pl $COLUMNS
}

################################################################################
# range ()
# Converts a comma separated pair of arguments, and prints a range between the
# start and calculated end positions.
# Expects 2 arguments:
#    start-position 
#    length         
# Variables changed
#    None
################################################################################
range() { start=$(echo $1 | cut -d ',' -f1)
	len=$(echo $1 | cut -d ',' -f2)
	end=$(echo "$start + $len - 1" | bc)
	echo "$start-$end"; 
}

################################################################################
# I keep a running list of projects in $HOME/.project. This command is used
# to search through my project file.
################################################################################
project() {
	echo "================================================================================"
	touch $HOME/.project
	egrep -i $1 $HOME/.project
	echo "================================================================================"
}

################################################################################
# Returns today's date in YYYYMMDD format.
################################################################################
alias dts='date +%Y%m%d'

################################################################################
# Returns timestamp in YYYY-MM-DD_HH:MM:SS format.
################################################################################
alias timestamp='date +%Y-%m-%d_%H:%M:%S'

################################################################################
# Returns timestamp in YYYYMMDDHHMMSS format.
################################################################################
alias fts='date +%Y%m%d%H%M%S'

################################################################################
# Create a directory named with the current date in YYYYMMDD format. Takes
# the name of the directory where you want to create the directory as an
# argument. If no argument is given, creates directory in current directory.
################################################################################
dmd () 
{ 
    ( if [ "$1"x != "x" ]; then cd $1; fi
        mkdir $(dts) )
}

## Set options for ls
if [ $OSTYPE="linux-gnu" ]
then
    export LS_OPTIONS="-N --color=tty -T 0"
else
    export LS_OPTIONS=""
fi
alias ls='/bin/ls $LS_OPTIONS'

## Make bc use floating point.
alias bc='bc -l'

## Sum a column of numbers
alias plsum="perl -e '\$sum=0; while(<>){\$sum+=\$_}; print \"\$sum\\n\"'"

## Yields date in YYYYMMDD format
mydate=$(date +%Y%m%d)

## list given directory in reverse-time  order
past () { 
    if [ $OSTYPE="linux-gnu" ]
    then
        TIME_STYLE='--time-style=+"%Y-%m-%d %H:%M:%S"'
    else
        TIME_STYLE=''
    fi
    ls -lart "$TIME_STYLE" "$@"; 
}

## Alias common misspellings of 'past'
alias ll=past
alias pat=past
alias paset=past
alias psat=past

## Echo all of the arguments, underlined with '=' characters.
title () {
	echo "$@" | perl -ne 'chomp; print "\n$_\n"; print "=" x length($_) . "\n" '
}

## use 'slice' as a text filter to chop off the number of characters equal to the
## width of the argument string. For example, to remove the permissions string from
## ls -l, you could use
## $ ls -l | slice "-rw-r--r--  "
slice() { cut -c$((${#1}+1))-; }

alias s3='sqlite3'

alias browse='gnome-open .'

## Create a text box around a quoted string.
box() { t="$1xxxx";c=${2:-=}; echo ${t//?/$c}; echo "$c $1 $c"; echo ${t//?/$c}; }

## Recover a borked terminal
alias sane=reset

alias dush="du -sm *|sort -n|tail"

comment() { echo "" > /dev/null; }

## disable calling vim through X
alias vim='/usr/bin/vim -X'

## add this command to $HOME/.bashtemprc
addtemp() { echo "$@" >> $HOME/.bashtemprc; }
alias addtmp='addtemp'

## Grep process list
psg() { ps aux | egrep $@ | egrep -v "egrep $@"; }

## History grep
hg() { history | egrep $@ | egrep -v "egrep $@"; }

vimcmd() { $1 > $2 && vim $2; }

pdffile() { gnome-open $(find ~/PDF | sort -t '_' -k2n | tail -1); }

export BROWSER='/usr/bin/firefox'

# use $google when DNS is down.
export google='74.125.65.104'

svnpath() { svn info | sed -n '/URL:/s/URL: //p'; }

alias svndir='svnpath'

cdl() { cd $1; past; }

################################################################################
# lastfile ()
# Arguments: directory
# Find the most recent file in the directory given by $1.
################################################################################
lastfile() {
    find ${1:-.} -maxdepth 1 -type f -printf "%T+ %p\n" | sort -n | tail -1 | sed 's/[^[:space:]]\+ //'
}

xmltidy() { tidy -xml -i "$@" 2> /dev/null ; }

gripe() {
    echo '-- ' $@ >> $HOME/.gripefile
}

fifo () {
    local fifo="$HOME/fifo"
    if [ ! -e $fifo ] 
    then
        mkfifo $fifo
    elif [ ! -p $fifo ]
    then
        echo "$fifo exists, but is not a named pipe"
        return 1
    fi
    cat > $fifo
}


sfifo () {
    local PASTE='xsel -o'
    if [ which xsel ]
    then
        PASTE='xsel -o'
    else
        PASTE='pbpaste'
    fi
    local fifo="$HOME/fifo"
    if [ ! -e $fifo ] 
    then
        mkfifo $fifo
    elif [ ! -p $fifo ]
    then
        echo "$fifo exists, but is not a named pipe"
        return 1
    fi
    $PASTE > $fifo
}

jpg2svg () {
    jpgname=$1
    base=$(echo $jpgname | sed 's/\.jpg$//i' )
    jpegtopnm $jpgname | pnmscale 2 | ppmtopgm | ppmdither -dim 2 | potrace -s -o $base.svg
    ls -lart $base.svg 
}

vimgn () {
    perl -e '@F=split( ":", $ARGV[0]); system("vim +$F[1] $F[0]")' $@
}
